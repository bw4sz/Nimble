{
    "contents" : "---\ntitle: \"Building a model (state-space model example)\"\nsubtitle: \"NIMBLE training materials module\"\nauthor: \"NIMBLE Development Team\"\noutput:\n  html_document:\n    code_folding: show\n---\n\n```{r chunksetup, include=FALSE} \n# Following code is only needed for slide generation, not for using R code separately.\nlibrary(methods)\n```\n```{r loadnimble, include=FALSE}\nlibrary(nimble)\n```\n\n# A basic example: population state-space model\n\nWe'll use an example from Chapter 5 of K&eacute;ry and Schaub\n(2012)\\footnote{Marc K&eacute;ry  and Michael Schaub. 2012. Bayesian Population Analysis Using WinBUGS: A hierarchical perspective.  Elsevier / Academic Press.}\n\nCode and data are available from the [BPA web site](http://www.vogelwarte.ch/de/projekte/publikationen/bpa/complete-code-and-data-files-of-the-book.html), in bpa-code.txt.\n\n### Summary\n\n   - House martin counts (1990 - 2009) by Reto Freuler\n   - Exponential population model with population growth rate varying each year\n   - Log-normal observations of population size.\n   - Parameters to estimate: mean and variance of population growth rate; observation variance.\n   - Latent states: True population size in each year.\n   - The example also generates predictions through 2015.\n\n### BUGS \\& NIMBLE code for the model\n\nThis has been simplified (without changing the model) from the book's code files.\n\n```{r model-code}\nlibrary(nimble)\nssmCode <- nimbleCode({\n        # Priors and constraints\n        logN.est[1] ~ dnorm(5.6, 0.01)  # Prior for initial population size\n        mean.r ~ dnorm(1, 0.001)        # Prior for mean growth rate\n        sigma.proc ~ dunif(0, 1)        # Prior for sd of state process\n        sigma.obs ~ dunif(0, 1)         # Prior for sd of observation process\n\n        # State process\n        for (t in 1:(T-1)){\n            r[t] ~ dnorm(mean.r, sd = sigma.proc)\n            logN.est[t+1] <- logN.est[t] + r[t]\n        }\n\n        # Observation process \n        for (t in 1:T) {\n           y[t] ~ dnorm(logN.est[t], sd = sigma.obs)\n        }\n\n        # Population sizes on real scale\n        for (t in 1:T) {\n            N.est[t] <- exp(logN.est[t])\n        }\n})\n```\n\n# Building a model in NIMBLE\n\n   - WinBUGS/OpenBUGS/JAGS: provide code, data and (optional) initial values at one time, and the software runs an MCMC.\n   - NIMBLE gives more control: data is different from constants and can be set and modified later.  Model is separate from algorithms.\n\nBuilding the state-space model in one step:\n```{r build-model}\n# Code from BPA book:\npyears <- 6 # Number of future years with predictions\nhm <- c(271, 261, 309, 318, 231, 216, 208, 226, 195, 226, 233, 209, \n   226, 192, 191, 225, 245, 205, 191, 174, rep(NA, pyears))\nyear <- 1990:(2009 + pyears)\n\n# Bundle data\nbugs.data <- list(y = log(hm), T = length(year))\n## NIMBLE will handle y as data, T as a constant\n\n# Initial values\ninits <- function(){\n      list(sigma.proc = runif(1, 0, 1), mean.r = rnorm(1),\n                         sigma.obs = runif(1, 0, 1), \n                         logN.est = c(rnorm(1, 5.6, 0.1), \n                                  rep(NA, (length(year)-1))))\n}\n\nssm <- nimbleModel(ssmCode, constants = bugs.data, \n    inits = inits()) # inits handled as function call here (can be fixed)\n```\n\nNote that `nimbleModel` returns an object with which you can program. This will be covered later.\n\n# Compiling a model\n\nIn general, you'll want a version of the model that allows for fast computation (this can then be used by any algorithms you use on the model).\n\nTo create a fast compiled version of the model, you simply do this.\n\n```{r, compile-model}\nCssm <- compileNimble(ssm)\n```\n\n# Looking at the model's graph\n\nA central concept for hierarchical statistical modeling is:\n\n   - Think of the model as a graph, typically a directed acyclic graph\n   (DAG).\n   - Every line of BUGS code declares a node on the graph.\n\nWe can harness NIMBLE's use of the `igraph` library to plot the graph.\n\n```{r, plot-graph, fig.cap=\"\"}\n## Remove N.est[t] to reduce clutter \nssmCode <- nimbleCode({\n        # Priors and constraints\n        logN.est[1] ~ dnorm(5.6, 0.01)       # Prior for initial population size\n        mean.r ~ dnorm(1, 0.001)             # Prior for mean growth rate\n        sigma.proc ~ dunif(0, 1)             # Prior for sd of state process\n        sigma.obs ~ dunif(0, 1)              # Prior for sd of observation process\n\n        # State process\n        for (t in 1:(T-1)){\n            r[t] ~ dnorm(mean.r, sd = sigma.proc)\n            logN.est[t+1] <- logN.est[t] + r[t]\n        }\n\n        # Observation process\n          for (t in 1:T) y[t] ~ dnorm(logN.est[t], sd = sigma.obs)\n})\n\n# Make a smaller version so the graph wil be readable\nssmSmall <- nimbleModel(ssmCode, constants = list(T = 5),\n                        data = list(y = bugs.data$y[1:5]))\nlibrary(igraph)\ngraph <- ssmSmall$getGraph()\nplot(graph, layout = layout_(graph, with_kk())) ## uses plot.igraph\n```\n\n`igraph`'s plot function doesn't know how to lay out a state-space model\nbut this looks somewhat ok.\n",
    "created" : 1467059417782.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2043265646",
    "id" : "523DBAD8",
    "lastKnownWriteTime" : 1466997139,
    "path" : "~/nimble-isec-2016/build_model.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_markdown"
}